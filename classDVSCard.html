<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DVSCard class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.9.1 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; </center>
<hr><h1>DVSCard  Class Reference</h1>Object representing access to a DVS video board. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="DVSClasses_8h-source.html">DVSClasses.h</a>&gt;</code>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a0">~DVSCard</a> ()  throw ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Standard destructor.</em> <a href="#a0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a1">DVSCard</a> (short card_number)  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a DVSCard object to access a DVS video board.</em> <a href="#a1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a2">destroy_CardHandles</a> ()  throw ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destroy all <a class="el" href="classDVSHandle.html">DVSHandle</a> objects for this DVSCard.</em> <a href="#a2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a11">sync</a> (int syncmode)  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sets the genlocking (synchronisation) mode of the DVS video board.</em> <a href="#a11">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Obtaining exclusive access to the DVS driver API.</div></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a3">lock_mutex</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Locks mutex to prevent others accessing DVS driver API.</em> <a href="#a3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a4">unlock_mutex</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Unlocks mutex to allow others to access DVS driver API.</em> <a href="#a4">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Equivalents of DVS driver API functions.</div></td></tr>
<tr><td colspan="2"><div class="groupText">Provided for convenience.
<p>
These versions throw exceptions.<br><br></div></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a5">set_VideoMode</a> (int videomode)  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sets the video configuration of the DVS board.</em> <a href="#a5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a6">query</a> (int query_cmd, int query_sub_param, const char *errcontext)  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Calls <code>sv_query(...)</code> function in DVS driver API.</em> <a href="#a6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a7">get_IOFieldOrder</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the field/frame mode of video input and output from the DVS board.</em> <a href="#a7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a8">get_BufFieldOrder</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the field/frame mode in which video is stored in buffers and memory.</em> <a href="#a8">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a9">get_VideoMode</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the current video configuration of the DVS board.</em> <a href="#a9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a10">get_FIFOBufferSizeReq</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the number of bytes required to hold a frame/field of video.</em> <a href="#a10">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">FIFO DMA facilities for video acquisition/output.</div></td></tr>
<tr><td nowrap align=right valign=top>sv_fifo *&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a12">FIFO_StartDMAInput</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Start the video acquisition FIFO.</em> <a href="#a12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>sv_fifo *&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a13">FIFO_StartDMAOutput</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Start the video outputting FIFO.</em> <a href="#a13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a14">FIFO_StopDMAInput</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Stop the video acquisition FIFO.</em> <a href="#a14">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a15">FIFO_StopDMAOutput</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Stop the video outputting FIFO.</em> <a href="#a15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a16">FIFO_GetFrame</a> (bool waitIfEmpty, unsigned char *field1Buffer, int size1, unsigned char *field2Buffer=NULL, int size2=0, <a class="el" href="classDVSTC.html">DVSTC</a> *tc1=NULL, <a class="el" href="classDVSTC.html">DVSTC</a> *tc2=NULL)  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Acquire a frame of video (blocking, non threaded).</em> <a href="#a16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a17" doxytag="DVSCard::FIFO_GetFrame"></a>
void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a17">FIFO_GetFrame</a> (unsigned char *field1Buffer, int size1, unsigned char *field2Buffer=NULL, int size2=0)  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><b>DEPRECIATED:</b> See FIFO_GetFrame(bool, unsigned char*, int, unsigned char*, int).</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a18">FIFO_PutFrame</a> (unsigned char *field1Buffer, int size1, unsigned char *field2Buffer=NULL, int size2=0)  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Output a frame of video (blocking, non threaded).</em> <a href="#a18">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a> (bool waitIfEmpty, unsigned char *nextField1Buffer, int size1, unsigned char *nextField2Buffer=NULL, int size2=0, <a class="el" href="classDVSTC.html">DVSTC</a> *tc1=NULL, <a class="el" href="classDVSTC.html">DVSTC</a> *tc2=NULL)  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Complete the background acquisition of a frame of video (if any), and start the acquisition of another (multithreaded).</em> <a href="#a19">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a20" doxytag="DVSCard::FIFO_BackgroundGetNextFrame"></a>
void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a20">FIFO_BackgroundGetNextFrame</a> (unsigned char *nextField1Buffer, int size1, unsigned char *nextField2Buffer=NULL, int size2=0)  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><b>DEPRECIATED:</b> See FIFO_BackgroundGetNextFrame(bool, unsigned char*, int, unsigned char*, int).</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a21">FIFO_FinishBackgroundGetNextFrame</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Complete the background acquisition of a frame of video.</em> <a href="#a21">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a22">FIFO_BackgroundPutFrame</a> (unsigned char *field1Buffer, int size1, unsigned char *field2Buffer=NULL, int size2=0)  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Output a frame of video in the background (multithreaded).</em> <a href="#a22">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#a23">FIFO_FinishBackgroundPutFrame</a> ()  throw (DVSException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Catch the completion of video outputting thread.</em> <a href="#a23">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Static Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#d0">destroy_AllCards</a> (bool destroyHandles)  throw ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destroys ALL DVSCard objects.</em> <a href="#d0">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Static Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constants for common video modes.</div></td></tr>
<tr><td colspan="2"><div class="groupText">For use as parameters to set_VideoMode (or <code>sv_videomode()</code>)<br><br></div></td></tr>
<tr><td nowrap align=right valign=top><a name="p0" doxytag="DVSCard::VIDEOMODE_PAL_FRAMES_RGBA_BOTTOM2TOP_NOAUDIO"></a>
const int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#p0">VIDEOMODE_PAL_FRAMES_RGBA_BOTTOM2TOP_NOAUDIO</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Video with alpha no audio, frames, PAL, RGBA component byte order, bottom most line at lowest address (Suitable for use with DVSClassesGL / OpenGL).</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="p1" doxytag="DVSCard::VIDEOMODE_PAL_FRAMES_BGR_BOTTOM2TOP_NOAUDIO"></a>
const int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#p1">VIDEOMODE_PAL_FRAMES_BGR_BOTTOM2TOP_NOAUDIO</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Video no audio, frames, PAL, BGR component byte order, bottom most line at lowest address (Suitable for use with DVSClassesGL / OpenGL).</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="p2" doxytag="DVSCard::VIDEOMODE_PAL_FRAMES_RGB_BOTTOM2TOP_NOAUDIO"></a>
const int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#p2">VIDEOMODE_PAL_FRAMES_RGB_BOTTOM2TOP_NOAUDIO</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Video no audio, frames, RGB component byte order, bottom most line at lowest address.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="p3" doxytag="DVSCard::VIDEOMODE_PAL_FRAMES_RGBA_NOAUDIO"></a>
const int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#p3">VIDEOMODE_PAL_FRAMES_RGBA_NOAUDIO</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Video with alpha no audio, frames, RGBA component byte orer, top most line at lowest address.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="p4" doxytag="DVSCard::VIDEOMODE_PAL_FRAMES_BGR_NOAUDIO"></a>
const int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#p4">VIDEOMODE_PAL_FRAMES_BGR_NOAUDIO</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Video no audio, frames, BGR component byte orer, top most line at lowest address.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="p5" doxytag="DVSCard::VIDEOMODE_PAL_FRAMES_RGB_NOAUDIO"></a>
const int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#p5">VIDEOMODE_PAL_FRAMES_RGB_NOAUDIO</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Video no audio, frames, RGB component byte orer, top most line at lowest address.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>const int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#p6">VIDEOMODE_PAL_FIELDS_RGBA_NOAUDIO</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Video with alpha no audio, separate fields, RGBA component byte orer, top most line at lowest address.</em> <a href="#p6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>const int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#p7">VIDEOMODE_PAL_FIELDS_BGR_NOAUDIO</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Video no audio, separate fields, BGR component byte orer, top most line at lowest address.</em> <a href="#p7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="p8" doxytag="DVSCard::VIDEOMODE_PAL_FIELDS_RGB_NOAUDIO"></a>
const int&nbsp;</td><td valign=bottom><a class="el" href="classDVSCard.html#p8">VIDEOMODE_PAL_FIELDS_RGB_NOAUDIO</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Video no audio, separate fields, RGB component byte orer, top most line at lowest address.</em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Friends</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="l0" doxytag="DVSCard::DVSHandle"></a>
class&nbsp;</td><td valign=bottom><b>DVSHandle</b></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Object representing access to a DVS video board.
<p>

<p>
The DVSCard object provides a range of member functions to manipulate its video board; primarily methods for configuring the board for common simple tasks and for acquiring or outputting frames of video. All these functions throw exceptions rather than returning error codes.
<p>

<p>
<b>Functions Acquisition and Outputting of frames</b> 
<p>
DVSCard provides a range of functions for acquiring and outputting video frames. These use the FIFO API functions provided by the DVS driver.
<p>
First, call <a class="el" href="classDVSCard.html#a12">FIFO_StartDMAInput</a>() or <a class="el" href="classDVSCard.html#a13">FIFO_StartDMAOutput</a>() (depending on whether you are acquiring or outputting frames).
<p>

<p>
Two modes of operation are then available: blocking and background (threaded). <ul>
<li><a class="el" href="classDVSCard.html#a16">FIFO_GetFrame</a>() or <a class="el" href="classDVSCard.html#a18">FIFO_PutFrame</a>() will block until the acquisition or output is complete. See <a class="el" href="classDVSCard.html#a16">FIFO_GetFrame</a>() and <a class="el" href="classDVSCard.html#a18">FIFO_PutFrame</a>() for details.<br>
 <li><a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>() or <a class="el" href="classDVSCard.html#a22">FIFO_BackgroundPutFrame</a>() will launch a separate thread to perform the acquisition or output and will return immediately. Note that to use these methods, background acquisition or outputting must be 'started' and 'stopped'. <a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>() and <a class="el" href="classDVSCard.html#a22">FIFO_BackgroundPutFrame</a>() for more details. </ul>

<p>
<b>Directly accessing the DVS driver API</b> 
<p>
The DVSCard class does not provide equivalents of all functions in the DVS driver API. The <a class="el" href="classDVSHandle.html">DVSHandle</a> class is therefore provided to give you access to the DVS driver handle for a given DVS video board.
<p>

<p>
<a class="el" href="classDVSHandle.html">DVSHandle</a> and DVSCard objects provide access to a mutex, allowing obtain exclusive access whilst calling DVS driver API functions. See <a class="el" href="classDVSCard.html#a3">lock_mutex</a>() and <a class="el" href="classDVSCard.html#a4">unlock_mutex</a>(). 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="DVSCard::~DVSCard"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
DVSCard::~DVSCard 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw ()          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Standard destructor.
<p>
Destroys this DVSCard object and informs any <a class="el" href="classDVSHandle.html">DVSHandle</a> objects that the DVSCard no longer exists (subsequent attempts to use <a class="el" href="classDVSHandle.html">DVSHandle</a> objects will result in <a class="el" href="classDVSNullHandleException.html">DVSNullHandleException</a> being raised). However, the <a class="el" href="classDVSHandle.html">DVSHandle</a> objects are <em>not</em> destroyed. To do that, call the destroy_CardHandles method prior to destroying the DVSCard object. Any FIFO actions are stopped and terminated (both blocking and background).     </td>
  </tr>
</table>
<a name="a1" doxytag="DVSCard::DVSCard"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
DVSCard::DVSCard 
          </td>
          <td class="md">(&nbsp</td>
          <td class="md">short          </td>
          <td class="mdname"> <em>card_number</em>          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a DVSCard object to access a DVS video board.
<p>
<dl compact><dt>
Parameters: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>card_number
</em>&nbsp;</td><td>
Allows you to select which DVS board (if there is more than one) you wish to access. Cards are numbered zero upwards. </td></tr>
</table>
</dl>
<p>
Only <em>one</em> DVSCard object can be created for each DVS board present in the computer. Attempts to create more than one for the same <code>card_number</code> will cause an exception to be thrown. <dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSCardAlreadyUsedException
</em>&nbsp;</td><td>
 Thrown if an attempt is made to instantiate more than one DVSCard object for the same card number </td></tr>
<tr><td valign=top><em>DVSCannotOpenHandleException
</em>&nbsp;</td><td>
 Thrown if the attempt to obtain a handle to the board from the DVS driver API failed. This could be because no board is installed with that card number, or if another process or thread has requested the handle already. </td></tr>
<tr><td valign=top><em>DVSInternalErrorException
</em>&nbsp;</td><td>
 Thrown if there is an internal fault. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="d0" doxytag="DVSCard::destroy_AllCards"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::destroy_AllCards 
          </td>
          <td class="md">(&nbsp</td>
          <td class="md">bool          </td>
          <td class="mdname"> <em>destroyHandles</em>          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw ()<code> [static]</code>          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroys ALL DVSCard objects.
<p>
This static method can be used for clean-up on termination. It destroyes all DVSCard objects instantiated by your program. <dl compact><dt>
Parameters: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>destroyHandles
</em>&nbsp;</td><td>
Set to <b>true</b> to cause all <a class="el" href="classDVSHandle.html">DVSHandle</a> objects to also be destroyed. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="DVSCard::destroy_CardHandles"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::destroy_CardHandles 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw ()          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy all <a class="el" href="classDVSHandle.html">DVSHandle</a> objects for this DVSCard.
<p>
This method forcibly destroys all <a class="el" href="classDVSHandle.html">DVSHandle</a> objects instantiated from this DVSCard object.     </td>
  </tr>
</table>
<a name="a3" doxytag="DVSCard::lock_mutex"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::lock_mutex 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Locks mutex to prevent others accessing DVS driver API.
<p>
If you need to call DVS driver API functions directly, rather than using the subset provided through DVSCard, then ensure that you surround any such calls with <a class="el" href="classDVSCard.html#a3">lock_mutex</a>() and <a class="el" href="classDVSCard.html#a4">unlock_mutex</a>(). This ensures that multiple threads of execution will not clash. 
<p>
These methods are provided both in <a class="el" href="classDVSHandle.html">DVSHandle</a> and DVSCard objects. 
<p>
Ensure that the mutex is unlocked in any exception handling you may do. The example below guarantees to try its upmost to unlock the mutex in the event of an exception, as well as under normal execution: <pre> <a class="el" href="classDVSHandle.html">DVSHandle</a> *my_handle = new DVSHandle(my_dvscard);

 my_handle-&gt;mutex_lock();
 try
 {
   int retval = &lt;call to a dvs driver function&gt;
   if (reval != SV_OK)
     throw myexception();
 }
 catch (...)
 {
   try { my_handle-&gt;mutex_unlock(); } catch (...) { }
   throw;
 }
 my_handle-&gt;mutex_unlock();

 delete my_handle;</pre>
<p>
<dl compact><dt>
<b>Note: </b><dd>
<ul>
<li>This mechanism works only if it is applied every time a DVS driver API function is called. It only takes one uncooperative section of code to spoil it for everyone! <li>Do NOT call any methods in this class library whilst the mutex is locked, otherwise they will block indefinately. </ul>
</dl>    </td>
  </tr>
</table>
<a name="a4" doxytag="DVSCard::unlock_mutex"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::unlock_mutex 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlocks mutex to allow others to access DVS driver API.
<p>
<dl compact><dt>
<b>See also: </b><dd>
<a class="el" href="classDVSCard.html#a3">lock_mutex</a>() </dl>    </td>
  </tr>
</table>
<a name="a5" doxytag="DVSCard::set_VideoMode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::set_VideoMode 
          </td>
          <td class="md">(&nbsp</td>
          <td class="md">int          </td>
          <td class="mdname"> <em>videomode</em>          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the video configuration of the DVS board.
<p>
Equivalent of <code>sv_videomode(int videomode)</code> in DVS driver API. A set of constants for commonly used modes has been provided. <dl compact><dt>
Parameters: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>videomode
</em>&nbsp;</td><td>
Specifies the video mode configuration. Use either the common video mode constants (listed above), or specify your own (see DVS SDK documentation for <code>sv_videomode</code>. </td></tr>
</table>
</dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 if the call to sv_videomode fails. </td></tr>
</table>
</dl><dl compact><dt>
<b>See also: </b><dd>
<a target="top" href="../../sdk.pdf">DVS SDK documentation</a> for <code>sv_videomode()</code> </dl>    </td>
  </tr>
</table>
<a name="a6" doxytag="DVSCard::query"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
int DVSCard::query 
          </td>
          <td class="md">(&nbsp</td>
          <td class="md">int          </td>
          <td class="mdname"> <em>query_cmd</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">int          </td>
          <td class="mdname"> <em>query_sub_param</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">const char *          </td>
          <td class="mdname"> <em>errcontext</em> = "DVSCard::query() : sv_query(...)"          </td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls <code>sv_query(...)</code> function in DVS driver API.
<p>
<dl compact><dt>
Parameters: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>query_cmd
</em>&nbsp;</td><td>
Specifies the query to execute. </td></tr>
<tr><td valign=top><em>query_sub_param
</em>&nbsp;</td><td>
Specifies a parameter, particular to the query specified in <code>query_cmd</code>. </td></tr>
<tr><td valign=top><em>errcontext
</em>&nbsp;</td><td>
NULL, or (optionally) a constant string describing the context in which this call is made (in case an exception is thrown due to an error). </td></tr>
</table>
</dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 if the call to sv_query fails. </td></tr>
</table>
</dl><dl compact><dt>
<b>See also: </b><dd>
<a target="top" href="../../sdk.pdf">DVS SDK documentation</a> for <code>sv_query()</code> </dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="DVSCard::get_IOFieldOrder"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
int DVSCard::get_IOFieldOrder 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the field/frame mode of video input and output from the DVS board.
<p>
Calls <code>sv_query(SV_QUERY_INTERLACEID_VIDEO, 0, ...)</code> function in the DVS driver API. <dl compact><dt>
<b>Returns: </b><dd>
<table border=1 cellspacing=3 cellpadding=3><tr><td>1</td><td>: video input/output is progressive (frames) </td></tr>
<tr><td> 12</td><td>: first field in each frame contains the top-most line </td></tr>
<tr><td> 21</td><td>: second field in each frame contains the top-most line</td></table>
</dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 if the call to sv_query fails. </td></tr>
<tr><td valign=top><em>DVSInternalErrorException
</em>&nbsp;</td><td>
 Thrown if <code>sv_query()</code> returns an invalid value
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Note: </b><dd>
<ul>
<li>This method does <em>not</em> query the format in which the video is written into/read from buffers in memory. To do that, use get_BufFieldOrder </ul>
</dl><dl compact><dt>
<b>See also: </b><dd>
<a target="top" href="../../sdk.pdf">DVS SDK documentation</a> for <code>sv_query()</code> </dl>    </td>
  </tr>
</table>
<a name="a8" doxytag="DVSCard::get_BufFieldOrder"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
int DVSCard::get_BufFieldOrder 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the field/frame mode in which video is stored in buffers and memory.
<p>
Calls <code>sv_query(SV_QUERY_INTERLACEID_STORAGE, 0, ...)</code> function in the DVS driver API. <dl compact><dt>
<b>Returns: </b><dd>
<table border=1 cellspacing=3 cellpadding=3><tr><td>1</td><td>: video input/output is progressive (frames) </td></tr>
<tr><td> 12</td><td>: first field in each frame contains the top-most line </td></tr>
<tr><td> 21</td><td>: second field in each frame contains the top-most line</td></table>
</dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 if the call to sv_query fails. </td></tr>
<tr><td valign=top><em>DVSInternalErrorException
</em>&nbsp;</td><td>
 Thrown if <code>sv_query()</code> returns an invalid value
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Note: </b><dd>
<ul>
<li>This method does <em>not</em> query the format in which the video comes into or goes out of the board (as SDI). To do that, use get_IOFieldOrder </ul>
</dl><dl compact><dt>
<b>See also: </b><dd>
<a target="top" href="../../sdk.pdf">DVS SDK documentation</a> for <code>sv_query()</code> </dl>    </td>
  </tr>
</table>
<a name="a9" doxytag="DVSCard::get_VideoMode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
int DVSCard::get_VideoMode 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current video configuration of the DVS board.
<p>
Calls <code>sv_query(SV_QUERY_MODE_CURRENT, 0, ...)</code> function in the DVS driver API. <dl compact><dt>
<b>Returns: </b><dd>
See <a target="top" href="../../sdk.pdf">DVS SDK documentation</a> for <code>sv_query()</code></dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 if the call to sv_query fails. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="DVSCard::get_FIFOBufferSizeReq"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
int DVSCard::get_FIFOBufferSizeReq 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of bytes required to hold a frame/field of video.
<p>
Calls <code>sv_storage_status(...)</code> function in the DVS driver API. <dl compact><dt>
<b>Returns: </b><dd>
See <a target="top" href="../../sdk.pdf">DVS SDK documentation</a> for <code>sv_storage_status()</code> and <code>struct sv_storageinfo</code></dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 if the call to sv_storage_status fails. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a11" doxytag="DVSCard::sync"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::sync 
          </td>
          <td class="md">(&nbsp</td>
          <td class="md">int          </td>
          <td class="mdname"> <em>syncmode</em>          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the genlocking (synchronisation) mode of the DVS video board.
<p>
Calls <code>sv_sync</code> function in the DVS driver API. <dl compact><dt>
Parameters: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>syncmode
</em>&nbsp;</td><td>
See DVS SDK documentation for possible values. Common choices are: <code>SV_SYNC_GENLOCK_ANALOG</code> and <code>SV_SYNC_GENLOCK_DIGITAL</code>.</td></tr>
</table>
</dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 if the call to sv_sync fails.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>See also: </b><dd>
<a target="top" href="../../sdk.pdf">DVS SDK documentation</a> for <code>sv_sync()</code> </dl>    </td>
  </tr>
</table>
<a name="a12" doxytag="DVSCard::FIFO_StartDMAInput"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
sv_fifo * DVSCard::FIFO_StartDMAInput 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start the video acquisition FIFO.
<p>
This method initialises the DVS video board's FIFO I/O system for video acquisition. This method must be called once, prior to using <a class="el" href="classDVSCard.html#a16">FIFO_GetFrame</a>() or <a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>(). 
<p>
If video acquisition is needed again after the FIFO is stopped, by calling <a class="el" href="classDVSCard.html#a14">FIFO_StopDMAInput</a>(); then this method must be called again to restart the FIFO. <dl compact><dt>
<b>Returns: </b><dd>
DVS driver handle for the acquisition FIFO (in case you wish to access it directly)</dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 Thrown if there is an error in initialising and starting the FIFO.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Note: </b><dd>
<ul>
<li> Calls to this method when the FIFO is already started will have no effect. <li> You may run both the input and the output FIFOs at the same time. </ul>
</dl>    </td>
  </tr>
</table>
<a name="a13" doxytag="DVSCard::FIFO_StartDMAOutput"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
sv_fifo * DVSCard::FIFO_StartDMAOutput 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start the video outputting FIFO.
<p>
This method initialises the DVS video board's FIFO I/O system for video outputting. This method must be called once, prior to using <a class="el" href="classDVSCard.html#a18">FIFO_PutFrame</a>() or <a class="el" href="classDVSCard.html#a22">FIFO_BackgroundPutFrame</a>(). 
<p>
If video outputting is needed again after the FIFO is stopped, by calling <a class="el" href="classDVSCard.html#a15">FIFO_StopDMAOutput</a>(); then this method must be called again to restart the FIFO. <dl compact><dt>
<b>Returns: </b><dd>
DVS driver handle for the outputting FIFO (in case you wish to access it directly)</dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 Thrown if there is an error in initialising and starting the FIFO.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Note: </b><dd>
<ul>
<li> Calls to this method when the FIFO is already started will have no effect. <li> You may run both the input and the output FIFOs at the same time. </ul>
</dl>    </td>
  </tr>
</table>
<a name="a14" doxytag="DVSCard::FIFO_StopDMAInput"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::FIFO_StopDMAInput 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stop the video acquisition FIFO.
<p>
This method stops the DVS video board's video acquisition FIFO. It will also stop any background acquisition by waiting for and catching the thread's termination. <dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 Thrown if there is an error when stopping the FIFO.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Note: </b><dd>
<ul>
<li> Calls to this method when the FIFO is not yet started will have no effect. <li> <a class="el" href="classDVSCard.html#a0">~DVSCard</a>() calls this method, so you do not need to call it if you are about to call <a class="el" href="classDVSCard.html#a0">~DVSCard</a>(). </ul>
</dl>    </td>
  </tr>
</table>
<a name="a15" doxytag="DVSCard::FIFO_StopDMAOutput"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::FIFO_StopDMAOutput 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stop the video outputting FIFO.
<p>
This method stops the DVS video board's video acquisition FIFO. It will also stop any background acquisition by waiting for and catching the thread's termination. <dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 Thrown if there is an error when stopping the FIFO.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Note: </b><dd>
<ul>
<li> Calls to this method when the FIFO is not yet started will have no effect. <li> <a class="el" href="classDVSCard.html#a0">~DVSCard</a>() calls this method, so you do not need to call it if you are about to call <a class="el" href="classDVSCard.html#a0">~DVSCard</a>(). </ul>
</dl>    </td>
  </tr>
</table>
<a name="a16" doxytag="DVSCard::FIFO_GetFrame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::FIFO_GetFrame 
          </td>
          <td class="md">(&nbsp</td>
          <td class="md">bool          </td>
          <td class="mdname"> <em>waitIfEmpty</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">unsigned char *          </td>
          <td class="mdname"> <em>field1Buffer</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">int          </td>
          <td class="mdname"> <em>size1</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">unsigned char *          </td>
          <td class="mdname"> <em>field2Buffer</em> = NULL,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">int          </td>
          <td class="mdname"> <em>size2</em> = 0,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md"><a class="el" href="classDVSTC.html">DVSTC</a> *          </td>
          <td class="mdname"> <em>tc1</em> = NULL,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md"><a class="el" href="classDVSTC.html">DVSTC</a> *          </td>
          <td class="mdname"> <em>tc2</em> = NULL          </td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire a frame of video (blocking, non threaded).
<p>
Acquires a frame of video from the input FIFO, placing it into the buffers specified by the arguments to this method. Usage of arguments varies depending on whether the DVS board is configured to store frames as frames or separate fields.<dl compact><dt>
Parameters: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>waitIfEmpty
</em>&nbsp;</td><td>
If the video input fifo is empty, and <code>waitIfEmpty</code> is <code>false</code> then <a class="el" href="classDVSFIFOEmptyException.html">DVSFIFOEmptyException</a> will be thrown immediately. If <code>true</code>, then the acquisition thread will wait for 50 vsyncs (timed by the DVS board) before throwing <a class="el" href="classDVSFIFOEmptyException.html">DVSFIFOEmptyException</a> </td></tr>
<tr><td valign=top><em>field1Buffer
</em>&nbsp;</td><td>
<ul>
<li>If configured for frames: a pointer to a buffer into which the frame can be placed. <li>If configured for fields: a pointer to a buffer into which the first field can be placed. </ul>
</td></tr>
<tr><td valign=top><em>size1
</em>&nbsp;</td><td>
The size (in bytes) of the buffer pointed to by /p field1Buffer. </td></tr>
<tr><td valign=top><em>field2Buffer
</em>&nbsp;</td><td>
<ul>
<li>If configured for frames: <code>NULL</code> <li>If configured for fields: a pointer to a buffer into which the second field can be placed. </ul>
</td></tr>
<tr><td valign=top><em>size2
</em>&nbsp;</td><td>
The size (in bytes) of the buffer pointed to by /p field2Buffer, or <code>0</code> if /p field2Buffer is <code>NULL</code>. </td></tr>
<tr><td valign=top><em>tc1
</em>&nbsp;</td><td>
Pass a <a class="el" href="classDVSTC.html">DVSTC</a> timecode object to be filled with the VITC timecode of the first field. </td></tr>
<tr><td valign=top><em>tc2
</em>&nbsp;</td><td>
Pass a <a class="el" href="classDVSTC.html">DVSTC</a> timecode object to be filled with the VITC timecode of the second field.</td></tr>
</table>
</dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSFIFOEmptyException
</em>&nbsp;</td><td>
 Thrown if the acquisition FIFO was empty. </td></tr>
<tr><td valign=top><em>DVSFIFONotStartedException
</em>&nbsp;</td><td>
 Thrown if the acquisition FIFO has not been started (by calling <a class="el" href="classDVSCard.html#a12">FIFO_StartDMAInput</a>()) </td></tr>
<tr><td valign=top><em>DVSFIFOInUseException
</em>&nbsp;</td><td>
 Thrown if the acquisition FIFO is in use by a background acquisition thread. </td></tr>
<tr><td valign=top><em>DVSBadArgumentsException
</em>&nbsp;</td><td>
 Thrown if the arguments supplied were not suitable. For example, if you supply pointers to buffers for both fields, when the DVS video board is configured to store as frames. </td></tr>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 Thrown if any calls to the DVS driver API fail.
<p>
</td></tr>
</table>
</dl>
<p>
The example below instantiates access to a DVS board, configures it, then grabs 10 frames and processes them. Note that for clarity, this example contains no exception handling. <pre>   DVSCard *mycard = new DVSCard(0);
   mycard-&gt;set_VideoMode(VIDEOMODE_PAL_FRAMES_RGB_NOAUDIO);
   mycard-&gt;<a class="el" href="classDVSCard.html#a12">FIFO_StartDMAInput</a>();

   int bufsize = mycard-&gt;<a class="el" href="classDVSCard.html#a10">get_FIFOBufferSizeReq</a>();
   unsigned char *mybuf = new unsigned char[bufsize];

   for(int i=0; i&lt;10; i++)
   {
     mycard-&gt;FIFO_GetFrame(true, mybuf, bufsize, NULL, 0);
     my_frame_processing_func(mybuf, bufsize);
   }

   mycard-&gt;<a class="el" href="classDVSCard.html#a14">FIFO_StopDMAInput</a>();
   delete mycard;
   delete mybuf;</pre>
<p>
<dl compact><dt>
<b>Note: </b><dd>
<ul>
<li> This method blocks until the frame has been acquired (a process whic takes some time). If you require a high frame-rate, use <a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>(). <li> If you want to be able to cope with drop-outs in the video signal, ensure that you catch <a class="el" href="classDVSFIFOEmptyException.html">DVSFIFOEmptyException</a> and <a class="el" href="classDVSDriverException.html">DVSDriverException</a>. <li> In the above example, you do not need to call <a class="el" href="classDVSCard.html#a14">FIFO_StopDMAInput</a>() either, because <a class="el" href="classDVSCard.html#a0">~DVSCard</a>() does this for you. <li> You should <em>not</em> mix calls to <a class="el" href="classDVSCard.html#a16">FIFO_GetFrame</a>() and <a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>(). If you have been calling <a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>(), ensure you call <a class="el" href="classDVSCard.html#a21">FIFO_FinishBackgroundGetNextFrame</a>() before calling <a class="el" href="classDVSCard.html#a16">FIFO_GetFrame</a>(). </ul>
</dl>    </td>
  </tr>
</table>
<a name="a18" doxytag="DVSCard::FIFO_PutFrame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::FIFO_PutFrame 
          </td>
          <td class="md">(&nbsp</td>
          <td class="md">unsigned char *          </td>
          <td class="mdname"> <em>field1Buffer</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">int          </td>
          <td class="mdname"> <em>size1</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">unsigned char *          </td>
          <td class="mdname"> <em>field2Buffer</em> = NULL,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">int          </td>
          <td class="mdname"> <em>size2</em> = 0          </td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Output a frame of video (blocking, non threaded).
<p>
Outputs a frameof video via the output FIFO. Usage of arguments varies depending on whether the DVS board is configured to store frames as frames or separate fields.<dl compact><dt>
Parameters: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>field1Buffer
</em>&nbsp;</td><td>
<ul>
<li>If configured for frames: a pointer to a buffer containing the frame to be output. <li>If configured for fields: a pointer to a buffer containing the first field to be output. </ul>
</td></tr>
<tr><td valign=top><em>size1
</em>&nbsp;</td><td>
The size (in bytes) of the buffer pointed to by /p field1Buffer. </td></tr>
<tr><td valign=top><em>field2Buffer
</em>&nbsp;</td><td>
<ul>
<li>If configured for frames: <code>NULL</code> <li>If configured for fields: a pointer to a buffer containing the second field to be output. </ul>
</td></tr>
<tr><td valign=top><em>size2
</em>&nbsp;</td><td>
The size (in bytes) of the buffer pointed to by /p field2Buffer, or <code>0</code> if /p field2Buffer is <code>NULL</code>.</td></tr>
</table>
</dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSFIFONotStartedException
</em>&nbsp;</td><td>
 Thrown if the acquisition FIFO has not been started (by calling <a class="el" href="classDVSCard.html#a12">FIFO_StartDMAInput</a>()) </td></tr>
<tr><td valign=top><em>DVSFIFOInUseException
</em>&nbsp;</td><td>
 Thrown if the acquisition FIFO is in use by a background outputting thread. </td></tr>
<tr><td valign=top><em>DVSBadArgumentsException
</em>&nbsp;</td><td>
 Thrown if the arguments supplied were not suitable. For example, if you supply pointers to buffers for both fields, when the DVS video board is configured to store as frames. </td></tr>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 Thrown if any calls to the DVS driver API fail.
<p>
</td></tr>
</table>
</dl>
<p>
The example below instantiates access to a DVS board, configures it, then outputs 10 frames. Note that for clarity, this example contains no exception handling. <pre>   DVSCard *mycard = new DVSCard(0);
   mycard-&gt;set_VideoMode(DVSCard::VIDEOMODE_PAL_FRAMES_RGB_NOAUDIO);
   mycard-&gt;<a class="el" href="classDVSCard.html#a13">FIFO_StartDMAOutput</a>();

   int bufsize = mycard-&gt;<a class="el" href="classDVSCard.html#a10">get_FIFOBufferSizeReq</a>();
   unsigned char *mybuf = new unsigned char[bufsize];

   for(int i=0; i&lt;10; i++)
   {
     fill_frame_with_my_graphics(mybuf, bufsize);
     mycard-&gt;FIFO_PutFrame(mybuf, bufsize, NULL, 0);
   }

   mycard-&gt;<a class="el" href="classDVSCard.html#a15">FIFO_StopDMAOutput</a>();
   delete mycard;
   delete mybuf;</pre>
<p>
<dl compact><dt>
<b>Note: </b><dd>
<ul>
<li> This method blocks until the frame has been output (a process whic takes some time). If you require a high frame-rate, use <a class="el" href="classDVSCard.html#a22">FIFO_BackgroundPutFrame</a>(). <li> In the above example, you do not need to call <a class="el" href="classDVSCard.html#a15">FIFO_StopDMAOutput</a>() either, because <a class="el" href="classDVSCard.html#a0">~DVSCard</a>() does this for you. <li> You should <em>not</em> mix calls to <a class="el" href="classDVSCard.html#a18">FIFO_PutFrame</a>() and <a class="el" href="classDVSCard.html#a22">FIFO_BackgroundPutFrame</a>(). If you have been calling <a class="el" href="classDVSCard.html#a22">FIFO_BackgroundPutFrame</a>(), ensure you call <a class="el" href="classDVSCard.html#a23">FIFO_FinishBackgroundPutFrame</a>() before calling <a class="el" href="classDVSCard.html#a18">FIFO_PutFrame</a>(). </ul>
</dl>    </td>
  </tr>
</table>
<a name="a19" doxytag="DVSCard::FIFO_BackgroundGetNextFrame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::FIFO_BackgroundGetNextFrame 
          </td>
          <td class="md">(&nbsp</td>
          <td class="md">bool          </td>
          <td class="mdname"> <em>waitIfEmpty</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">unsigned char *          </td>
          <td class="mdname"> <em>nextField1Buffer</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">int          </td>
          <td class="mdname"> <em>size1</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">unsigned char *          </td>
          <td class="mdname"> <em>nextField2Buffer</em> = NULL,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">int          </td>
          <td class="mdname"> <em>size2</em> = 0,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md"><a class="el" href="classDVSTC.html">DVSTC</a> *          </td>
          <td class="mdname"> <em>tc1</em> = NULL,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md"><a class="el" href="classDVSTC.html">DVSTC</a> *          </td>
          <td class="mdname"> <em>tc2</em> = NULL          </td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Complete the background acquisition of a frame of video (if any), and start the acquisition of another (multithreaded).
<p>
Catches the completion of any background acquisition thread that may be running. If you made a previous call to <a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>(), the buffers specified in that call will now contain a captured frame of video. It then immediately starts another background acquisition thread that will place the acquired frame into the buffers specified by the arguments to this method. Usage of arguments varies depending on whether the DVS board is configured to store frames as frames or separate fields.<dl compact><dt>
Parameters: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>waitIfEmpty
</em>&nbsp;</td><td>
If the video input fifo is empty, and <code>waitIfEmpty</code> is <code>false</code> then <a class="el" href="classDVSFIFOEmptyException.html">DVSFIFOEmptyException</a> will be thrown immediately. If <code>true</code>, then the acquisition thread will wait for 50 vsyncs (timed by the DVS board) before throwing <a class="el" href="classDVSFIFOEmptyException.html">DVSFIFOEmptyException</a> </td></tr>
<tr><td valign=top><em>field1Buffer
</em>&nbsp;</td><td>
<ul>
<li>If configured for frames: a pointer to a buffer into which the frame can be placed. <li>If configured for fields: a pointer to a buffer into which the first field can be placed. </ul>
</td></tr>
<tr><td valign=top><em>size1
</em>&nbsp;</td><td>
The size (in bytes) of the buffer pointed to by /p field1Buffer. </td></tr>
<tr><td valign=top><em>field2Buffer
</em>&nbsp;</td><td>
<ul>
<li>If configured for frames: <code>NULL</code> <li>If configured for fields: a pointer to a buffer into which the second field can be placed. </ul>
</td></tr>
<tr><td valign=top><em>size2
</em>&nbsp;</td><td>
The size (in bytes) of the buffer pointed to by /p field2Buffer, or <code>0</code> if /p field2Buffer is <code>NULL</code>. </td></tr>
<tr><td valign=top><em>tc1
</em>&nbsp;</td><td>
Pass a <a class="el" href="classDVSTC.html">DVSTC</a> timecode object to be filled with the VITC timecode of the first field. </td></tr>
<tr><td valign=top><em>tc2
</em>&nbsp;</td><td>
Pass a <a class="el" href="classDVSTC.html">DVSTC</a> timecode object to be filled with the VITC timecode of the second field.
<p>
</td></tr>
</table>
</dl>The buffers will not be ready until after the next call to <a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>() or <a class="el" href="classDVSCard.html#a21">FIFO_FinishBackgroundGetNextFrame</a>() finishes.<dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSFIFOEmptyException
</em>&nbsp;</td><td>
 Thrown if the now-completed previous acquisition thread failed because the input FIFO was empty. (see note below) </td></tr>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 Thrown if the now-completed previous acquisition thread failed on a call to the DVS driver API. (see note below) </td></tr>
<tr><td valign=top><em>DVSFIFONotStartedException
</em>&nbsp;</td><td>
 Thrown if unable to start a new acquisition thread because the acquisition FIFO has not been started (done by calling <a class="el" href="classDVSCard.html#a12">FIFO_StartDMAInput</a>()) </td></tr>
<tr><td valign=top><em>DVSBadArgumentsException
</em>&nbsp;</td><td>
 Thrown if unable to start a new acquisition thread because the arguments supplied were not suitable. For example, if you supply pointers to buffers for both fields, when the DVS video board is configured to store as frames.
<p>
</td></tr>
</table>
</dl>
<p>
The example below instantiates access to a DVS board, configures it, then inputs and processes 10 frames. It uses <em>double buffering</em> because the buffer being acquired by the background thread will not be immediately ready. Note that for clarity, this example contains no exception handling. <pre>   DVSCard *mycard = new DVSCard(0);
   mycard-&gt;set_VideoMode(DVSCard::VIDEOMODE_PAL_FRAMES_RGB_NOAUDIO);
   mycard-&gt;<a class="el" href="classDVSCard.html#a12">FIFO_StartDMAInput</a>();

   int bufsize = mycard-&gt;<a class="el" href="classDVSCard.html#a10">get_FIFOBufferSizeReq</a>();
   unsigned char *mybuf[2] = { new unsigned char[bufsize], new unsigned char[bufsize] };
   int processingbuffer = 0;

   // fetch first frame
   mycard-&gt;FIFO_BackgroundGetNextFrame(mybuf[1-processingbuffer], bufsize, NULL, 0);
   processingbuffer = 1 - processingbuffer;

   // main loop
   for(int i=0; i&lt;10; i++)
   {
     if (i != 9)
       mycard-&gt;FIFO_BackgroundGetNextFrame(true, mybuf[1-processingbuffer], bufsize, NULL, 0);
     else
       mycard-&gt;<a class="el" href="classDVSCard.html#a21">FIFO_FinishBackgroundGetNextFrame</a>();

     my_frame_processing_func(mybuf[processingbuffer], bufsize, NULL, 0);

     processingbuffer = 1 - processingbuffer;
   }

   mycard-&gt;<a class="el" href="classDVSCard.html#a14">FIFO_StopDMAInput</a>();
   delete mycard;
   delete mybuf[0]
   delete mybuf[1];</pre>
<p>
<dl compact><dt>
<b>Note: </b><dd>
<ul>
<li> If an exception is thrown from the now-completed previous acquisition thread, <em>the new acquisition thread will still be started.</em> <li> You do not need to call <a class="el" href="classDVSCard.html#a21">FIFO_FinishBackgroundGetNextFrame</a>() in the above example, because <a class="el" href="classDVSCard.html#a15">FIFO_StopDMAOutput</a>() does this for you. <li> In fact you do not need to call <a class="el" href="classDVSCard.html#a14">FIFO_StopDMAInput</a>() either, because <a class="el" href="classDVSCard.html#a0">~DVSCard</a>() does this for you. <li> If an error occurs in the acquisition thread, this will not be thrown as an exception. Instead an error message will be sent to the std error output stream. This is because of a lack of support of exception handling with thread cancellation in current implementations of pthreads. </ul>
</dl>    </td>
  </tr>
</table>
<a name="a21" doxytag="DVSCard::FIFO_FinishBackgroundGetNextFrame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::FIFO_FinishBackgroundGetNextFrame 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Complete the background acquisition of a frame of video.
<p>
Catches the completion of any background acquisition thread that may be running. The buffers you specified in the previous call to <a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>() will now contain a captured frame of video. See <a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>() for an example of how this is used.<dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSFIFOEmptyException
</em>&nbsp;</td><td>
 Thrown if the now-completed previous acquisition thread failed because the input FIFO was empty. (see note below) </td></tr>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 Thrown if the now-completed previous acquisition thread failed on a call to the DVS driver API. (see note below)
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Note: </b><dd>
<ul>
<li> Calling this method without previously calling <a class="el" href="classDVSCard.html#a19">FIFO_BackgroundGetNextFrame</a>() will have no effect. <li> <a class="el" href="classDVSCard.html#a14">FIFO_StopDMAInput</a>() will automatically call this method if needed. You therefore do not need to call it yourself if you are about to call <a class="el" href="classDVSCard.html#a14">FIFO_StopDMAInput</a>() or <a class="el" href="classDVSCard.html#a0">~DVSCard</a>(). <li> If an error occurs in the acquisition thread, this will not be thrown as an exception. Instead an error message will be sent to the std error output stream. This is because of a lack of support of exception handling with thread cancellation in current implementations of pthreads. </ul>
</dl>    </td>
  </tr>
</table>
<a name="a22" doxytag="DVSCard::FIFO_BackgroundPutFrame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::FIFO_BackgroundPutFrame 
          </td>
          <td class="md">(&nbsp</td>
          <td class="md">unsigned char *          </td>
          <td class="mdname"> <em>field1Buffer</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">int          </td>
          <td class="mdname"> <em>size1</em>,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">unsigned char *          </td>
          <td class="mdname"> <em>field2Buffer</em> = NULL,           </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md">        <tr>
          <td></td>
          <td></td>
          <td class="md">int          </td>
          <td class="mdname"> <em>size2</em> = 0          </td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Output a frame of video in the background (multithreaded).
<p>
Catches the completion of any background outputting thread that may be running (launched by a prior call to <a class="el" href="classDVSCard.html#a22">FIFO_BackgroundPutFrame</a>()). Then launches a new background thread to output a new frame, pointed to by the arguments supplied to this method. Usage of arguments varies depending on whether the DVS board is configured to store frames as frames or separate fields.<dl compact><dt>
Parameters: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>field1Buffer
</em>&nbsp;</td><td>
<ul>
<li>If configured for frames: a pointer to a buffer containing the frame to be output. <li>If configured for fields: a pointer to a buffer containing the first field to be output. </ul>
</td></tr>
<tr><td valign=top><em>size1
</em>&nbsp;</td><td>
The size (in bytes) of the buffer pointed to by /p field1Buffer. </td></tr>
<tr><td valign=top><em>field2Buffer
</em>&nbsp;</td><td>
<ul>
<li>If configured for frames: <code>NULL</code> <li>If configured for fields: a pointer to a buffer containing the second field to be output. </ul>
</td></tr>
<tr><td valign=top><em>size2
</em>&nbsp;</td><td>
The size (in bytes) of the buffer pointed to by /p field2Buffer, or <code>0</code> if /p field2Buffer is <code>NULL</code>.</td></tr>
</table>
</dl><dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSDriverException
</em>&nbsp;</td><td>
 Thrown if the now-completed previous acquisition thread failed on a call to the DVS driver API. (see note below) </td></tr>
<tr><td valign=top><em>DVSFIFONotStartedException
</em>&nbsp;</td><td>
 Thrown if unable to start a new outputting thread because the outputting FIFO has not been started (done by calling <a class="el" href="classDVSCard.html#a13">FIFO_StartDMAOutput</a>()) </td></tr>
<tr><td valign=top><em>DVSBadArgumentsException
</em>&nbsp;</td><td>
 Thrown if unable to start a new outputting thread because the arguments supplied were not suitable. For example, if you supply pointers to buffers for both fields, when the DVS video board is configured to store as frames.
<p>
</td></tr>
</table>
</dl>
<p>
The example below instantiates access to a DVS video board, configures it, then outputs 10 frames. It uses <em>double buffering</em> because the buffer being output by the background thread must not be corrupted. Note that for clarity, this example contains no exception handling. <pre>   DVSCard *mycard = new DVSCard(0);
   mycard-&gt;set_VideoMode(DVSCard::VIDEOMODE_PAL_FRAMES_RGB_NOAUDIO);
   mycard-&gt;<a class="el" href="classDVSCard.html#a13">FIFO_StartDMAOutput</a>();

   int bufsize = mycard-&gt;<a class="el" href="classDVSCard.html#a10">get_FIFOBufferSizeReq</a>();
   unsigned char *mybuf[] = { new unsigned char[bufsize], new unsigned char[bufsize] };
   int fillbuf = 0;

   for(int i=0; i&lt;10; i++)
   {
     fill_frame_with_my_graphics(mybuf[fillbuf],bufsize);
     mycard-&gt;BackgroundPutFrame(mybuf[fillbuf], bufsize, NULL, 0);
     fillbuf = 1 - fillbuf;
   }

   mycard-&gt;<a class="el" href="classDVSCard.html#a23">FIFO_FinishBackgroundPutFrame</a>();
   mycard-&gt;<a class="el" href="classDVSCard.html#a15">FIFO_StopDMAOutput</a>();
   delete mycard;
   delete mybuf[0];
   delete mybuf[1];</pre>
<p>
<dl compact><dt>
<b>Note: </b><dd>
<ul>
<li> If an exception is thrown from the now-completed previous outputting thread, <em>the new outputting thread will still be started.</em> <li> The contents of field1Buffer (and field2Buffer if applicable) must remain valid until after your next call to <a class="el" href="classDVSCard.html#a22">FIFO_BackgroundPutFrame</a>() or <a class="el" href="classDVSCard.html#a23">FIFO_FinishBackgroundPutFrame</a>(). <li> You do not need to call <a class="el" href="classDVSCard.html#a23">FIFO_FinishBackgroundPutFrame</a>() in the above example, because <a class="el" href="classDVSCard.html#a15">FIFO_StopDMAOutput</a>() does this for you. <li> In fact you do not need to call <a class="el" href="classDVSCard.html#a15">FIFO_StopDMAOutput</a>() either, because <a class="el" href="classDVSCard.html#a0">~DVSCard</a>() does this for you. <li> If an error occurs in the outputting thread, this will not be thrown as an exception. Instead an error message will be sent to the std error output stream. This is because of a lack of support of exception handling with thread cancellation in current implementations of pthreads. </ul>
</dl>    </td>
  </tr>
</table>
<a name="a23" doxytag="DVSCard::FIFO_FinishBackgroundPutFrame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
void DVSCard::FIFO_FinishBackgroundPutFrame 
          </td>
          <td class="md">(&nbsp</td>
          <td class="mdname">          </td>
          <td class="md">)&nbsp;</td>
          <td class="md">  throw (<a class="el" href="classDVSException.html">DVSException</a>)          </td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Catch the completion of video outputting thread.
<p>
Catches the completion of any background outputting thread that may be running (launched by a prior call to <a class="el" href="classDVSCard.html#a22">FIFO_BackgroundPutFrame</a>()).<dl compact><dt>
Exceptions: <dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DVSFIFONotStartedException
</em>&nbsp;</td><td>
 Thrown if the acquisition FIFO has not been started (by calling <a class="el" href="classDVSCard.html#a12">FIFO_StartDMAInput</a>())
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Note: </b><dd>
<ul>
<li> If there is no background video outputting thread running, this method will have no effect. <li> <a class="el" href="classDVSCard.html#a15">FIFO_StopDMAOutput</a>() will automatically call this method if needed. You therefore do not need to call it yourself if you are about to call <a class="el" href="classDVSCard.html#a15">FIFO_StopDMAOutput</a>() or <a class="el" href="classDVSCard.html#a0">~DVSCard</a>(). <li> If an error occurs in the outputting thread, this will not be thrown as an exception. Instead an error message will be sent to the std error output stream. This is because of a lack of support of exception handling with thread cancellation in current implementations of pthreads. </ul>
</dl>    </td>
  </tr>
</table>
<hr><h2>Field Documentation</h2>
<a name="p6" doxytag="DVSCard::VIDEOMODE_PAL_FIELDS_RGBA_NOAUDIO"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
const int DVSCard::VIDEOMODE_PAL_FIELDS_RGBA_NOAUDIO<code> [static]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Video with alpha no audio, separate fields, RGBA component byte orer, top most line at lowest address.
<p>
(Suitable for use with DVSClassesGL)     </td>
  </tr>
</table>
<a name="p7" doxytag="DVSCard::VIDEOMODE_PAL_FIELDS_BGR_NOAUDIO"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> 
const int DVSCard::VIDEOMODE_PAL_FIELDS_BGR_NOAUDIO<code> [static]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Video no audio, separate fields, BGR component byte orer, top most line at lowest address.
<p>
(Suitable for use with DVSClassesGL)     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="DVSClasses_8h-source.html">DVSClasses.h</a><li>cards_and_handles.cc</ul>
<HR>
<A HREF="mailto:matt.hammond@rd.bbc.co.uk">Matt Hammond</A> BBC R&D.
Class library documentation created using <A HREF="http://www.doxygen.org/">doxygen</a> documentation generator.
